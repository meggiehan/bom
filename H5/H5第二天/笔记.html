<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>

    //delay()延迟事件。
    //online中l小写的时候表示一个事件，这个事件只能用DOM2级事件来绑定。
    // 当为大写时表示属性，后面不用加（）号，直接调用就可以了，返回一个布尔值。
    //当在全局使用的时候，Window可以不用写，但最好加上。
    //online有一个上线的过程，这个事件在PC端的时候，他一定是由离线状态变为上线状态时才被触发。

    //全屏操作并不会拉伸我们的盒子。
    //只能通过document来调用关闭的方法。
    //处于全屏为TRUE，退出全屏为FALSE。document.webkitIsFullScreen.

    //伪类：空伪类，目标伪类，全屏伪类。
    //weikit   谷歌浏览器前缀
    //moz      火狐浏览器
    //ms   IE浏览器
    //o    欧朋浏览器

    //移动端的浏览器使用的是谷歌内核，所以h5是都兼容的。
    //HTML页面在全屏的时候有特殊写法，document.documentElement.webkitRuquestFullScreen
    //所有元素在关闭的时候必须调用document
    //谷歌多了一个IS

    //file是一个dom对象，所以可以来进行遍历
    //百度里base64码，压缩图片的格式，优化网站，但是缺点是后期无法再次维护。

// 默认情况下，a链接和img是可以拖动的，但是设置了draggale=false则就不可以拖动了。
    //dragstart事件一定是点击加位移才会触发的事件。
    //dragend事件一定是位移以后松开鼠标才会触发。
    //拖拽元素开始在拖拽以后他的元素会变成光标，松开鼠标以后到回到原点的这段时间，元素会变成开始本身的大小。
    //dragleave一定是光标离开拖拽元素后才会触发的。离开盒子边界的时候就会触发。
    //drag事件只要拖拽开始，就会不停的触发，直到拖拽结束，期间不管光标移动与否，都会一直触发事件，不停止。

//drop是必须放在
    //dragenter事件一定是光标元素进入目标元素时才会触发。
    //dragover事件只要拖拽元素在目标元素内就会触发，无论光标是否移动。
    //dragover 不仅阻止了drop的事件还阻止了dragleave事件。同时还阻止了鼠标的托中事件。（阻止了一切不可控的事件）
    //drop是必须跟在dragover后面的，有一个执行顺序。并且只有在阻止了dragover的默认事件时才会执行drop和dragleave事件。
    //drop也有默认行为，阻止他在新的浏览器里打开这个图片。在任何一个网页里拖进一张图片时，
         // 会打开一个新的浏览器窗口并且显示这张图片，因为所有的都是在html中加载的，一层一层的执行，所以阻止的是这个事件。

    //location.href="";会跳转。
    //history.pushstate();增加一条历史记录。（对象（在添加历史时，会设置一些数据，））

    //pushstate有重复性。同一个网页也会执行多次。第一个值一般是空，在框架使用时才填写。
    //replacestate是指替换当前的页面，那个页面调用的跳转，哪个页面就是当前页面。
    //浏览器第一次打开就会有历史记录，就是当前那个网页的访问记录，当添加了第二条记录的时候，
          // 他就在之前的历史记录上再添加新的历史记录条数。
    //历史区发生改变以后，当再次执行前进或者后退的时候，才会改变popstate的设置值。(跨页面跨窗口的获取数据)。

    //cookie是一个特定的字符串。并且有长度的限制。
    //parent只能向上找一级，parents可以向上找到多级。
    //sessionstorage生命周期为关闭浏览器窗口时,localstorage的生命周期是永久生效的。（多窗口，多页面）
    // sessionstorage在同一个窗口下数据可以共享,若设置了返回null。
    //sessionstorage同窗口，多页面。
    //JSON.stringify()将来是通过ajax用这个来进行获取和设置的。
    //Websql即将被废弃。
    //跨域设置:是指域名端口号的改变，一般是由服务器的相互配合完成，一般本地的都无法跨域。


    //cache manifest
    //fallback是用来返回网页的，当有一个找不到了，那么就找一个备用的网页并且执行。前面是原本希望出现的网页，后面是要替换的网页
    //network使用了缓存下次需要更新的内容部分。
    //cache可以不写，最好写上。
    //随便写个注释的内容，可以使缓存列表进行更新，因为默认会把整个文件也当做是一个缓存内容放在最后，
        // 所以我们可以每次打开输入点内容，例如：#version1.0.0就可以进行重新读取，达到更新的效果。
    //从无网络变为有网络时，要在network中重新设置一下。
    //以后使用调试工具调试的时候，不要忘记清除一下缓存removeitem。因为不清除的话，浏览器会自动去缓存里跑，拿数据。
</script>
</body>
</html>